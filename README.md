# Automatic Struct of Array generation for Rust

[![Test](https://github.com/lumol-org/soa-derive/actions/workflows/tests.yml/badge.svg?branch=master)](https://github.com/lumol-org/soa-derive/actions/workflows/tests.yml)
[![Crates.io](https://img.shields.io/crates/v/soa_derive.svg)](https://crates.io/crates/soa_derive)

This crate provides a custom derive (`#[derive(StructOfArray)]`) to
automatically generate code from a given struct `T` that allow to replace
`Vec<T>` with a struct of arrays. For example, the following code

```rust
#[derive(StructOfArray)]
pub struct Cheese {
    pub smell: f64,
    pub color: (f64, f64, f64),
    pub with_mushrooms: bool,
    pub name: String,
}
```

will generate a `CheeseVec` struct that looks like this:

```rust
pub struct CheeseVec {
    pub smell: Vec<f64>,
    pub color: Vec<(f64, f64, f64)>,
    pub with_mushrooms: Vec<bool>,
    pub name: Vec<String>,
}
```

It will also generate the same functions that a `Vec<Cheese>` would have, and a
few helper structs: `CheeseSlice`, `CheeseSliceMut`, `CheeseRef` and
`CheeseRefMut` corresponding respectivly to `&[Cheese]`, `&mut [Cheese]`,
`&Cheese` and `&mut Cheese`.

Any struct derived by StructOfArray will auto impl trait `StructOfArray`.
You can use `<Cheese as StructOfArray>::Type` instead of the explicitly named type `CheeseVec`.

## How to use it

Add `#[derive(StructOfArray)]` to each struct you want to derive a struct of
array version. If you need the helper structs to derive additional traits (such
as `Debug` or `PartialEq`), you can add an attribute `#[soa_derive(Debug,
PartialEq)]` to the struct declaration.

```rust
#[derive(Debug, PartialEq, StructOfArray)]
#[soa_derive(Debug, PartialEq)]
pub struct Cheese {
    pub smell: f64,
    pub color: (f64, f64, f64),
    pub with_mushrooms: bool,
    pub name: String,
}
```

If you want to add attribute to a specific generated struct(such as
`#[cfg_attr(test, derive(PartialEq))]` on `CheeseVec`), you can add an
attribute `#[soa_attr(Vec, cfg_attr(test, derive(PartialEq)))]` to the
struct declaration.

```rust
#[derive(Debug, PartialEq, StructOfArray)]
#[soa_attr(Vec, cfg_attr(test, derive(PartialEq)))]
pub struct Cheese {
    pub smell: f64,
    pub color: (f64, f64, f64),
    pub with_mushrooms: bool,
    pub name: String,
}
```

Mappings for first argument of ``soa_attr`` to the generated struct for ``Cheese``:
* `Vec` => `CheeseVec`
* `Slice` => `CheeseSlice`
* `SliceMut` => `CheeseSliceMut`
* `Ref` => `CheeseRef`
* `RefMut` => `CheeseRefMut`
* `Ptr` => `CheesePtr`
* `PtrMut` => `CheesePtrMut`

## Usage and API

All the generated code have some generated documentation with it, so you
should be able to use `cargo doc` on your crate and see the documentation
for all the generated structs and functions.
Most of the time, you should be able to replace `Vec<Cheese>` by
`CheeseVec`, with exception of code using direct indexing in the vector and
a few other caveats listed below.

### Caveats and limitations

`Vec<T>` functionalities rely a lot on references and automatic *deref* feature,
for getting function from `[T]` and indexing. But the SoA vector (let's call it
`CheeseVec`, generated from the `Cheese` struct) generated by this crate can not
implement `Deref<Target=CheeseSlice>`, because `Deref` is required to return a
reference, and `CheeseSlice` is not a reference. The same applies to `Index` and
`IndexMut` trait, that can not return `CheeseRef/CheeseRefMut`.  This means that
the we can not index into a `CheeseVec`, and that a few functions are
duplicated, or require a call to `as_ref()/as_mut()` to change the type used.

## Iteration

It is possible to iterate over the values in a `CheeseVec`

```rust
let mut vec = CheeseVec::new();
vec.push(Cheese::new("stilton"));
vec.push(Cheese::new("brie"));

for cheese in vec.iter() {
    // when iterating over a CheeseVec, we load all members from memory
    // in a CheeseRef
    let typeof_cheese: CheeseRef = cheese;
    println!("this is {}, with a smell power of {}", cheese.name, cheese.smell);
}
```
One of the main advantage of the SoA layout is to be able to only load some
fields from memory when iterating over the vector. In order to do so, one
can manually pick the needed fields:

```rust
for name in &vec.name {
    // We get referenes to the names
    let typeof_name: &String = name;
    println!("got cheese {}", name);
}
```

In order to iterate over multiple fields at the same time, one can use the
[soa_zip!](https://docs.rs/soa_derive/*/soa_derive/macro.soa_zip.html) macro.

```rust
for (name, smell, color) in soa_zip!(vec, [name, mut smell, color]) {
    println!("this is {}, with color {:#?}", name, color);
    // smell is a mutable reference
    *smell += 1.0;
}
```

## Nested Struct of Arrays

In order to nest a struct of arrays inside another struct of arrays, one can use the `#[nested_soa]` attribute.

For example, the following code

```rust
#[derive(StructOfArray)]
pub struct Point {
    x: f32,
    y: f32,
}
#[derive(StructOfArray)]
pub struct Particle {
    #[nested_soa]
    point: Point,
    mass: f32,
}
```

will generate structs that looks like this:

```rust
pub struct PointVec {
    x: Vec<f32>,
    y: Vec<f32>,
}
pub struct ParticleVec {
    point: PointVec, // rather than Vec<Point>
    mass: Vec<f32>
}
```

All helper structs will be also nested, for example `PointSlice` will be nested in `ParticleSlice`.

## Documentation

Please see http://lumol.org/soa-derive/soa_derive_example/ for a small
example and the documentation of all the generated code.

## Benchmarks

Here are a few [simple benchmarks](benches/soa.rs) results, on my machine:

```
running 10 tests
test aos_big_do_work_100k   ... bench:     415,315 ns/iter (+/- 72,861)
test aos_big_do_work_10k    ... bench:      10,087 ns/iter (+/- 219)
test aos_big_push           ... bench:          50 ns/iter (+/- 10)
test aos_small_do_work_100k ... bench:      93,377 ns/iter (+/- 1,106)
test aos_small_push         ... bench:           3 ns/iter (+/- 1)
test soa_big_do_work_100k   ... bench:      93,719 ns/iter (+/- 2,793)
test soa_big_do_work_10k    ... bench:       9,253 ns/iter (+/- 103)
test soa_big_push           ... bench:          39 ns/iter (+/- 13)
test soa_small_do_work_100k ... bench:      93,301 ns/iter (+/- 1,765)
test soa_small_push         ... bench:           4 ns/iter (+/- 1)
```

Benchmarks tests exist for soa (struct of array) and aos (array of struct)
versions of the same code, using a small (24 bytes) and a big (240 bytes) struct.

You can run the same benchmarks on your own system by cloning this repository
and running `cargo bench`.

## Licensing and contributions

This crate distributed under either the MIT or the Apache license, at your
choice. Contributions are welcome, please open an issue before to discuss your
changes !

The code is based on an initial idea by @maikklein:  https://maikklein.github.io/post/soa-rust/
